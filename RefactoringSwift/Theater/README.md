이 프로그램의 설계를 보고 난 소감은 어떤가?

청구 내역을 HTML로 출력하는 기능이 필요하다고 가정해보자.
지금 상황에서는 우선 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야한다.
그러면 statement() 함수의 복잡도가 크게 증가한다.
이런 상황이라면 대부분 이 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리할 것이다.

이 방식은 나중에 수많은 문제를 일으킬 여지가 있다.
청구서 작성 로직을 변경할 때마다 기존 함수와 HTML 버전 함수 모두를 수정해야하기 때문이다.
게다가 정책이 복잡해질수록 수정할 부분을 찾기 어려워지고 수정 과정에서도 실수할 가능성도 커진다.

리팩터링이 필요한 이유는 바로 이러한 변경 때문이다.
잘 작동하고 나중에 변경할 일이 없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없다.

"프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다."

### 리팩터링의 첫 단계

리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다.
저자는 리팩터링 시 테스트에 상당히 의지한다. 내가 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문이다.
테스트를 작성하는 데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축된다.

statement()처럼 긴 함수를 리팩터링할 떄는 먼저 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다.
그러면 중간 즈음의 switch문이 가장 먼저 눈에 띌 것이다.

이 switch문을 살펴보면 한 번의 공연에 대한 요금을 계산하고 있다.
그러나 이러한 사실은 코드를 분석해서 얻은 정보다. 이런식으로 파악한 정보는 쉽게 휘발되기 때문에, 잊지 않으려면 재빨리 코드에 반영해야 한다.



